{
  "version": 3,
  "sources": ["../../../Trees/BinaryTree/index.ts"],
  "sourcesContent": ["class Node {\n  constructor(value) {\n    this.val = value\n    this.leftChild = null\n    this.rightChild = null\n  }\n}\n\nclass BinarySearchTree {\n  constructor(rootValue) {\n    this.root = new Node(rootValue)\n  }\n\n  // insert(newValue) {\n  //   if (this.root === null) {\n  //     this.root = new Node(newValue)\n  //     return;\n  //   }\n\n  //   let currentNode = this.root\n  //   let parent;\n\n\n  \n  //   while (currentNode) {\n  //     parent = currentNode\n  //     if (newValue < currentNode.val) {\n  //       currentNode = currentNode.leftChild\n  //     }  else {\n  //       currentNode = currentNode.rightChild\n  //     }\n  //   }\n\n  //   if (newValue < parant.val) {\n  //     parent.leftChild = new Node(newValue)\n  //   } else {\n  //     parent.rightChild = new Node(newValue)\n  //   }\n  // }\n\n  // recursive\n  insert(currentNode, newValue) {\n    if (currentNode === null) {\n      currentNode = new Node(newValue);\n    } else if (newValue < currentNode?.val) {\n      currentNode.leftChild = this.insert(currentNode?.leftChild, newValue);\n    } else {\n      currentNode.rightChild = this.insert(currentNode?.rightChild, newValue);\n    }\n    return currentNode;\n  }\n\n  insertBST(newValue) {\n    if(this.root==null){\n      this.root=new Node(newValue);\n      return;\n    }\n    this.insert(this.root, newValue);\n  }\n\n  preOrderPrint(currentNode) {\n    if (currentNode !== null) {\n      console.log(currentNode.val)\n      this.preOrderPrint(currentNode.leftChild)\n      this.preOrderPrint(currentNode.rightChild)\n    }\n  }\n\n  inOrderPrint(currentNode) {\n    if (currentNode !== null) {\n      this.inOrderPrint(currentNode.leftChild)\n      console.log(currentNode.val)\n      this.inOrderPrint(currentNode.rightChild)\n    }\n  }\n  postOrderPrint(currentNode) {\n    if (currentNode !== null) {\n      this.postOrderPrint(currentNode.leftChild)\n      this.postOrderPrint(currentNode.rightChild)\n      console.log(currentNode.val)\n    }\n  }\n\n  search(value) {\n    let currentNode = this.root\n    while (currentNode && (currentNode.val !== value)) {\n      if (value < currentNode.val) {\n        currentNode = currentNode.leftChild\n      } else {\n        currentNode = currentNode.rightChild\n      }\n    }\n\n    return currentNode\n  }\n\n  delete(currentNode, value) {\n    if (currentNode === null) {\n      return false\n    }\n\n    let parentNode\n    while (currentNode && currentNode.val !== value) {\n      parentNode = currentNode\n      if (value < currentNode.val) {\n        currentNode = currentNode.leftChild\n      } else {\n        currentNode = currentNode.rightChild\n      }\n    }\n\n    if (currentNode === null) {\n      return false\n    } else if (currentNode.leftChild === null && currentNode.rightChild == null) {\n      if (currentNode.val === this.root.val) {\n        this.root  = null\n        return true\n      } else if (currentNode.val < parentNode.val) {\n        parentNode.leftChild = null\n        return true\n      } else {\n        parentNode.rightChild = null\n        return true\n      }\n    } else if (currentNode.rightChild === null) {\n      if (currentNode.val === this.root.val) {\n        this.root = currentNode.leftChild\n        return true\n      } else if (currentNode.leftChild.val < parentNode.val) {\n        parentNode.leftChild = currentNode.leftChild\n        return true\n      } else {\n        parentNode.rightChild = currentNode.leftChild\n        return true\n      }\n    } else if (currentNode.leftChild === null) {\n      if(currentNode.val==this.root.val){\n        this.root = currentNode.rightChild;\n        return true;\n      } else if (currentNode.rightChild.val < parentNode.val) {\n        parentNode.leftChild = currentNode.rightChild\n        return true\n      } else {\n        parentNode.rightCHild = currentNode.rightChild\n        return true\n      }\n    } else {\n      let minRight = currentNode.rightChild\n\n      while (minRight.leftChild !== null) {\n        minRight = minRight.leftChild\n      }\n\n      let tmp = minRight.val\n\n      this.delete(this.root, minRight.val)\n      currentNode.val = tmp\n\n      return true\n    }\n    \n  }\n}\n\nlet BST = new BinarySearchTree(6)\nconsole.log('The root val for BST : ', BST.root.val)\n\n// Insert to recursive\nBST.insertBST(4)\nBST.insertBST(9)\nBST.insertBST(5)\nBST.insertBST(2)\nBST.insertBST(8)\nBST.insertBST(12)\nBST.insertBST(10)\nBST.insertBST(14)\n\n// General Insert not for recursive\n// BST.insert(4)\n// BST.insert(9)\n// BST.insert(5)\n// BST.insert(2)\n// BST.insert(8)\n// BST.insert(12)\n// BST.insert(10)\n// BST.insert(14)\n// console.log('',  BST.root)\n\nconsole.log('========preOrderPrint()=========')\nBST.preOrderPrint(BST.root);\n\n\nconsole.log('========inOrderPrint()=========')\nBST.inOrderPrint(BST.root);\n\nconsole.log('========postOrderPrint()=========')\nBST.postOrderPrint(BST.root);\n\nconsole.log('======== Search 8 =========')\nconsole.log(BST.search(8))\nconsole.log(BST.search(11))\nconsole.log(BST.search(12))\n\nlet BST2 = new BinarySearchTree(6)\nconsole.log(\"The root val for BST : \", BST2.root.val)\nBST2.insertBST(4);\nBST2.insertBST(9);\nBST2.insertBST(5);\nBST2.insertBST(2);\nBST2.insertBST(8);\nBST2.insertBST(12);\nBST2.insertBST(1)\nBST2.insertBST(3)\n\n// Deletion when val not found\n// BST2.inOrderPrint(BST2.root);\n// console.log(\"Delete 10!\")\n// console.log(BST2.delete(BST2.root,10))\n\n\n// Deleting a Leaf Node\n// BST2.inOrderPrint(BST2.root);\n// console.log(\"Delete 12!\")\n// console.log(BST2.delete(BST2.root,12))\n// BST2.inOrderPrint(BST2.root);\n\n// Deletion when the node to be deleted has a left child only\n// BST2.inOrderPrint(BST2.root);\n// console.log(\"Delete 1!\")\n// console.log(BST2.delete(BST2.root, 1));\n// BST.inOrderPrint(BST2.root)\n\n// Deletion when the node to be deleted has a right child only\n// BST2.inOrderPrint(BST2.root);\n// console.log(\"Delete 3!\")\n// console.log(BST2.delete(BST2.root, 3));\n// BST2.inOrderPrint(BST2.root)\n\n// Deletion when the node to be deleted has two children\nBST2.inOrderPrint(BST2.root);\nconsole.log(\"Delete 9!\")\nconsole.log(BST2.delete(BST2.root, 9));\nBST2.inOrderPrint(BST2.root)"],
  "mappings": "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",
  "names": []
}

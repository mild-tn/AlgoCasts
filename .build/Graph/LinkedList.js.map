{
  "version": 3,
  "sources": ["../../Graph/LinkedList.ts"],
  "sourcesContent": ["\"use strict\";\nconst Node = require('./Node.ts');\n\nmodule.exports = class LinkedList {\n  constructor() {\n    this.head = null;\n  }\n\n  //Insertion At Head  \n  insertAtHead(newData) {\n    let tempNode = new Node(newData);\n    tempNode.nextElement = this.head;\n    this.head = tempNode;\n    return this; //returning the updated list\n  }\n\n  isEmpty() {\n    return (this.head == null);\n  }\n\n  //function to print the linked list\n  printList() {\n    if (this.isEmpty()) {\n      console.log(\"Empty List\");\n      return false;\n    } else {\n      let temp = this.head;\n      while (temp != null) {\n        process.stdout.write(String(temp.data));\n        process.stdout.write(\" -> \");\n        temp = temp.nextElement;\n      }\n      console.log(\"null\");\n      return true;\n    }\n  }\n\n  getHead() {\n    return this.head;\n  }\n  setHead(newHead) {\n    this.head = newHead;\n    return this;\n  }\n  getListStr() {\n    if (this.isEmpty()) {\n      console.log(\"Empty List\");\n      return \"null\";\n    } else {\n      let st = \"\";\n      let temp = this.head\n      while (temp != null) {\n        st += String(temp.data);\n        st += \" -> \";\n        temp = temp.nextElement;\n      }\n      st += \"null\";\n      return st;\n    }\n  }\n  insertAtTail(newData) {\n    //Creating a new Node with data as newData\n    let node = new Node(newData);\n\n    //check for case when list is empty\n    if (this.isEmpty()) {\n      //Needs to Insert the new node at Head\n      this.head = node;\n      return this;\n    }\n\n    //Start from head\n    let currentNode = this.head;\n\n    //Iterate to the last element\n    while (currentNode.nextElement != null) {\n      currentNode = currentNode.nextElement;\n    }\n\n    //Make new node the nextElement of last node of list\n    currentNode.nextElement = node;\n    return this;\n  }\n  search(value) {\n    //Start from the first element\n    let currentNode = this.head;\n\n    //Traverse the list until you find the value or reach the end\n    while (currentNode != null) {\n      if (currentNode.data == value) {\n        return true; //value found\n      }\n      currentNode = currentNode.nextElement\n    }\n    return false; //value not found\n  }\n  deleteAtHead() {\n    //if list is empty, do nothing\n    if (this.isEmpty()) {\n      return this;\n    }\n    //Get the head and first element of the list\n    let firstElement = this.head;\n\n    //If list is not empty, link head to the nextElement of firstElement\n    this.head = firstElement.nextElement;\n\n    return this;\n  }\n  deleteVal(value) {\n    let deleted = null; //True or False\n    //Write code here\n\n    //if list is empty return false\n    if (this.isEmpty()) {\n      return false;\n    }\n\n    //else get pointer to head\n    let currentNode = this.head;\n    // if first node's is the node to be deleted, delete it and return true\n    if (currentNode.data == value) {\n      this.head = currentNode.nextElement;\n      return true;\n    }\n\n    // else traverse the list\n    while (currentNode.nextElement != null) {\n      // if a node whose next node has the value as data, is found, delete it from the list and return true\n      if (currentNode.nextElement.data == value) {\n        currentNode.nextElement = currentNode.nextElement.nextElement;\n        return true;\n      }\n      currentNode = currentNode.nextElement;\n    }\n    //else node was not found, return false\n    deleted = false;\n    return deleted;\n  }\n  deleteAtTail() {\n    // check for the case when linked list is empty\n    if (this.isEmpty()) {\n      return this;\n    }\n    //if linked list is not empty, get the pointer to first node\n    let firstNode = this.head;\n    //check for the corner case when linked list has only one element\n    if (firstNode.nextElement == null) {\n      this.deleteAtHead();\n      return this;\n    }\n    //otherwise traverse to reach second last node\n    while (firstNode.nextElement.nextElement != null) {\n      firstNode = firstNode.nextElement;\n    }\n    //since you have reached second last node, just update its nextElement pointer to point at null, skipping the last node\n    firstNode.nextElement = null;\n    return this;\n  }\n}"],
  "mappings": ";AACA,MAAM,OAAO,QAAQ;AAErB,OAAO,UAAU,iBAAiB;AAAA,EAChC,cAAc;AACZ,SAAK,OAAO;AAAA;AAAA,EAId,aAAa,SAAS;AACpB,QAAI,WAAW,IAAI,KAAK;AACxB,aAAS,cAAc,KAAK;AAC5B,SAAK,OAAO;AACZ,WAAO;AAAA;AAAA,EAGT,UAAU;AACR,WAAQ,KAAK,QAAQ;AAAA;AAAA,EAIvB,YAAY;AACV,QAAI,KAAK,WAAW;AAClB,cAAQ,IAAI;AACZ,aAAO;AAAA,WACF;AACL,UAAI,OAAO,KAAK;AAChB,aAAO,QAAQ,MAAM;AACnB,gBAAQ,OAAO,MAAM,OAAO,KAAK;AACjC,gBAAQ,OAAO,MAAM;AACrB,eAAO,KAAK;AAAA;AAEd,cAAQ,IAAI;AACZ,aAAO;AAAA;AAAA;AAAA,EAIX,UAAU;AACR,WAAO,KAAK;AAAA;AAAA,EAEd,QAAQ,SAAS;AACf,SAAK,OAAO;AACZ,WAAO;AAAA;AAAA,EAET,aAAa;AACX,QAAI,KAAK,WAAW;AAClB,cAAQ,IAAI;AACZ,aAAO;AAAA,WACF;AACL,UAAI,KAAK;AACT,UAAI,OAAO,KAAK;AAChB,aAAO,QAAQ,MAAM;AACnB,cAAM,OAAO,KAAK;AAClB,cAAM;AACN,eAAO,KAAK;AAAA;AAEd,YAAM;AACN,aAAO;AAAA;AAAA;AAAA,EAGX,aAAa,SAAS;AAEpB,QAAI,OAAO,IAAI,KAAK;AAGpB,QAAI,KAAK,WAAW;AAElB,WAAK,OAAO;AACZ,aAAO;AAAA;AAIT,QAAI,cAAc,KAAK;AAGvB,WAAO,YAAY,eAAe,MAAM;AACtC,oBAAc,YAAY;AAAA;AAI5B,gBAAY,cAAc;AAC1B,WAAO;AAAA;AAAA,EAET,OAAO,OAAO;AAEZ,QAAI,cAAc,KAAK;AAGvB,WAAO,eAAe,MAAM;AAC1B,UAAI,YAAY,QAAQ,OAAO;AAC7B,eAAO;AAAA;AAET,oBAAc,YAAY;AAAA;AAE5B,WAAO;AAAA;AAAA,EAET,eAAe;AAEb,QAAI,KAAK,WAAW;AAClB,aAAO;AAAA;AAGT,QAAI,eAAe,KAAK;AAGxB,SAAK,OAAO,aAAa;AAEzB,WAAO;AAAA;AAAA,EAET,UAAU,OAAO;AACf,QAAI,UAAU;AAId,QAAI,KAAK,WAAW;AAClB,aAAO;AAAA;AAIT,QAAI,cAAc,KAAK;AAEvB,QAAI,YAAY,QAAQ,OAAO;AAC7B,WAAK,OAAO,YAAY;AACxB,aAAO;AAAA;AAIT,WAAO,YAAY,eAAe,MAAM;AAEtC,UAAI,YAAY,YAAY,QAAQ,OAAO;AACzC,oBAAY,cAAc,YAAY,YAAY;AAClD,eAAO;AAAA;AAET,oBAAc,YAAY;AAAA;AAG5B,cAAU;AACV,WAAO;AAAA;AAAA,EAET,eAAe;AAEb,QAAI,KAAK,WAAW;AAClB,aAAO;AAAA;AAGT,QAAI,YAAY,KAAK;AAErB,QAAI,UAAU,eAAe,MAAM;AACjC,WAAK;AACL,aAAO;AAAA;AAGT,WAAO,UAAU,YAAY,eAAe,MAAM;AAChD,kBAAY,UAAU;AAAA;AAGxB,cAAU,cAAc;AACxB,WAAO;AAAA;AAAA;",
  "names": []
}
